// Syst√®me Invitations Personnalis√©es SMS/Email pour BOB
const axios = require('axios');

const STRAPI_URL = 'http://46.202.153.43:1337/api';

let authCache = {};

async function authenticateUser(email) {
  if (authCache[email]) return authCache[email];
  
  try {
    const response = await axios.post(`${STRAPI_URL}/auth/local`, {
      identifier: email,
      password: 'password123'
    });
    
    authCache[email] = {
      token: response.data.jwt,
      user: response.data.user
    };
    
    return authCache[email];
  } catch (error) {
    console.log(`‚ùå Auth failed: ${email}`);
    return null;
  }
}

function generatePersonalizedInvitation(type, item, invitee, sender, channel = 'app') {
  const baseUrl = 'https://bob-app.com';
  
  let invitation = {
    id: `INV_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type: type,
    item_id: item.documentId || item.id,
    sender_id: sender.user.id,
    sender_name: sender.user.username,
    invitee_email: invitee.email,
    invitee_name: invitee.name,
    channel: channel,
    created_at: new Date().toISOString(),
    status: 'sent'
  };
  
  if (type === 'bob') {
    invitation.subject = `${sender.user.username} propose un BOB qui pourrait t'int√©resser`;
    invitation.quick_actions = ['interested', 'contact', 'decline'];
    invitation.item_url = `${baseUrl}/bob/${item.documentId}`;
    
    if (channel === 'sms') {
      invitation.content = `üëã Salut ${invitee.name} !\n\n${sender.user.username} pense que ce BOB pourrait t'int√©resser :\n\n"${item.titre}"\nüíé ${item.bobizEchange || 10} BOBIZ\n\nüîó Voir ici : ${invitation.item_url}\n\nR√©ponds BOB1 pour √™tre int√©ress√©(e) !\n\nüì± App BOB`;
    } 
    else if (channel === 'email') {
      invitation.content = `
Bonjour ${invitee.name},

${sender.user.username} pense que ce BOB pourrait vous int√©resser !

"${item.titre}"
${item.description || 'Description non disponible'}

üíé Valeur : ${item.bobizEchange || 10} BOBIZ
üè∑Ô∏è Type : ${item.type}

Vous pouvez consulter les d√©tails complets et contacter ${sender.user.username} directement via ce lien :
${invitation.item_url}

Actions rapides :
- R√©pondre "INT√âRESS√â" pour manifester votre int√©r√™t
- Cliquer sur le lien pour voir plus de d√©tails
- Contacter directement ${sender.user.username}

Bonne journ√©e !
L'√©quipe BOB
      `;
    }
    else { // app notification
      invitation.content = `${sender.user.username} t'a envoy√© un BOB !\n\n"${item.titre}"\nüíé ${item.bobizEchange || 10} BOBIZ\n\nTouche pour voir les d√©tails !`;
    }
  }
  
  else if (type === 'event') {
    invitation.subject = `${sender.user.username} t'invite √† son √©v√©nement`;
    invitation.quick_actions = ['join', 'interested', 'maybe', 'decline'];
    invitation.item_url = `${baseUrl}/event/${item.documentId}`;
    
    const eventDate = new Date(item.dateDebut).toLocaleDateString('fr-FR');
    const eventTime = new Date(item.dateDebut).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
    
    if (channel === 'sms') {
      invitation.content = `üéâ Invitation √©v√©nement !\n\n${sender.user.username} t'invite :\n"${item.titre}"\n\nüìÖ ${eventDate} √† ${eventTime}\nüìç ${item.adresse}\n\nüë• Rejoins-nous !\nüîó ${invitation.item_url}\n\nR√©ponds EVENT1 pour confirmer !\n\nüì± App BOB`;
    }
    else if (channel === 'email') {
      invitation.content = `
Bonjour ${invitee.name},

Vous √™tes invit√©(e) √† l'√©v√©nement de ${sender.user.username} !

üéâ "${item.titre}"

üìÖ Date : ${eventDate}
üïê Heure : ${eventTime}
üìç Lieu : ${item.adresse}
üë• Participants max : ${item.maxParticipants}
üíé R√©compense : ${item.bobizRecompense} BOBIZ

Description :
${item.description || 'Description compl√®te disponible sur l\'app'}

Pour participer, consultez tous les d√©tails et confirmez votre pr√©sence :
${invitation.item_url}

Actions rapides :
- R√©pondre "PARTICIPE" pour confirmer votre venue
- R√©pondre "INT√âRESS√â" si vous n'√™tes pas s√ªr(e)
- Cliquer sur le lien pour plus d'informations

Au plaisir de vous y voir !
${sender.user.username} via BOB
      `;
    }
    else { // app notification
      invitation.content = `üéâ ${sender.user.username} t'invite √† son √©v√©nement !\n\n"${item.titre}"\nüìÖ ${eventDate} √† ${eventTime}\nüìç ${item.adresse}\n\nTouche pour r√©pondre !`;
    }
  }
  
  return invitation;
}

async function createPersonalizedInvitationsForBobs() {
  console.log('üíå === INVITATIONS PERSONNALIS√âES POUR BOBS ===');
  
  const auth = await authenticateUser('marie@bob.com');
  if (!auth) return [];
  
  const headers = { 'Authorization': `Bearer ${auth.token}` };
  
  try {
    // R√©cup√©rer quelques Bobs pour invitations
    const bobsResponse = await axios.get(`${STRAPI_URL}/echanges`, { headers });
    const bobs = bobsResponse.data.data.slice(0, 3);
    
    const invitations = [];
    
    // Donn√©es contacts pour invitations (simulation)
    const contacts = [
      { email: 'thomas@bob.com', name: 'Thomas', phone: '+33123456789' },
      { email: 'sophie@bob.com', name: 'Sophie', phone: '+33123456790' },
      { email: 'lucas@bob.com', name: 'Lucas', phone: '+33123456791' },
      { email: 'externe1@gmail.com', name: 'Julie Dupont', phone: '+33123456792' },
      { email: 'externe2@gmail.com', name: 'Pierre Martin', phone: '+33123456793' }
    ];
    
    for (const bob of bobs) {
      console.log(`\nüíå Invitations pour BOB: ${bob.titre}`);
      
      // S√©lectionner 3 contacts al√©atoires
      const selectedContacts = contacts.sort(() => 0.5 - Math.random()).slice(0, 3);
      
      for (const contact of selectedContacts) {
        // Alterner entre SMS et Email
        const channels = ['sms', 'email', 'app'];
        const channel = channels[Math.floor(Math.random() * channels.length)];
        
        const invitation = generatePersonalizedInvitation('bob', bob, contact, auth, channel);
        
        console.log(`üìß Envoi invitation ${channel} √† ${contact.name}`);
        console.log(`üéØ ID: ${invitation.id}`);
        console.log(`üì® Sujet: ${invitation.subject}`);
        
        // Simulation envoi selon canal
        if (channel === 'sms') {
          console.log(`üì± SMS vers ${contact.phone}`);
          console.log(`üí¨ Contenu: ${invitation.content.substring(0, 100)}...`);
        } else if (channel === 'email') {
          console.log(`üìß Email vers ${contact.email}`);
          console.log(`üí¨ Contenu: ${invitation.content.substring(0, 150)}...`);
        } else {
          console.log(`üì± Notification app √† ${contact.name}`);
          console.log(`üí¨ Contenu: ${invitation.content}`);
        }
        
        // Enregistrer l'invitation dans la conversation BOB
        try {
          await axios.post(`${STRAPI_URL}/messages`, {
            data: {
              contenu: `üíå INVITATION ENVOY√âE !\n\nInvitation ${channel.toUpperCase()} envoy√©e √† ${contact.name} (${contact.email})\n\nüìß Sujet: "${invitation.subject}"\nüéØ ID: ${invitation.id}\n\nEn attente de r√©ponse... üì≤`,
              typeConversation: 'echange',
              dateEnvoi: new Date().toISOString(),
              expediteur: auth.user.id,
              echange: bob.id
            }
          }, { headers });
          
          console.log(`‚úÖ Invitation enregistr√©e dans conversation BOB`);
          
        } catch (error) {
          console.log(`‚ùå Erreur enregistrement: ${error.response?.data?.error?.message}`);
        }
        
        invitations.push({
          ...invitation,
          bob_id: bob.id,
          bob_title: bob.titre
        });
        
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    
    console.log(`\nüíå ${invitations.length} invitations BOB envoy√©es`);
    return invitations;
    
  } catch (error) {
    console.log(`‚ùå Erreur invitations BOB: ${error.message}`);
    return [];
  }
}

async function createPersonalizedInvitationsForEvents() {
  console.log('\nüéâ === INVITATIONS PERSONNALIS√âES POUR √âV√âNEMENTS ===');
  
  const auth = await authenticateUser('thomas@bob.com');
  if (!auth) return [];
  
  const headers = { 'Authorization': `Bearer ${auth.token}` };
  
  try {
    // R√©cup√©rer quelques √©v√©nements
    const eventsResponse = await axios.get(`${STRAPI_URL}/evenements`, { headers });
    const events = eventsResponse.data.data.slice(0, 2);
    
    const invitations = [];
    
    // Contacts pour √©v√©nements (plus large)
    const eventContacts = [
      { email: 'marie@bob.com', name: 'Marie', phone: '+33123456788', relation: 'proche' },
      { email: 'sophie@bob.com', name: 'Sophie', phone: '+33123456790', relation: 'amie' },
      { email: 'lucas@bob.com', name: 'Lucas', phone: '+33123456791', relation: 'collegue' },
      { email: 'famille1@gmail.com', name: 'Isabelle Durand', phone: '+33123456794', relation: 'famille' },
      { email: 'voisin1@gmail.com', name: 'Marc Voisin', phone: '+33123456795', relation: 'voisin' },
      { email: 'coll√®gue1@company.com', name: 'Sarah Leclerc', phone: '+33123456796', relation: 'collegue' }
    ];
    
    for (const event of events) {
      console.log(`\nüéâ Invitations pour EVENT: ${event.titre}`);
      
      // S√©lectionner contacts selon type √©v√©nement
      const selectedContacts = eventContacts.sort(() => 0.5 - Math.random()).slice(0, 4);
      
      for (const contact of selectedContacts) {
        // Prioriser email pour √©v√©nements
        const channels = ['email', 'sms', 'app'];
        const weights = [0.6, 0.3, 0.1]; // 60% email, 30% SMS, 10% app
        const random = Math.random();
        let channel = 'email';
        
        if (random < weights[2]) channel = 'app';
        else if (random < weights[1] + weights[2]) channel = 'sms';
        
        const invitation = generatePersonalizedInvitation('event', event, contact, auth, channel);
        
        // Personnaliser selon relation
        if (contact.relation === 'famille') {
          invitation.content = invitation.content.replace('Bonjour', 'Coucou');
          invitation.content = invitation.content.replace('vous', 'tu');
          invitation.content = invitation.content.replace('Vous √™tes', 'Tu es');
        }
        
        console.log(`üéâ Envoi invitation ${channel} √† ${contact.name} (${contact.relation})`);
        console.log(`üéØ ID: ${invitation.id}`);
        console.log(`üì® Sujet: ${invitation.subject}`);
        
        // Simulation envoi personnalis√©
        if (channel === 'sms') {
          console.log(`üì± SMS personnalis√© vers ${contact.phone}`);
          console.log(`üí¨ Aper√ßu: ${invitation.content.substring(0, 120)}...`);
        } else if (channel === 'email') {
          console.log(`üìß Email d√©taill√© vers ${contact.email}`);
          console.log(`üí¨ Aper√ßu: ${invitation.content.substring(0, 200)}...`);
        } else {
          console.log(`üì± Push notification √† ${contact.name}`);
          console.log(`üí¨ Message: ${invitation.content}`);
        }
        
        // Enregistrer dans conversation √©v√©nement
        try {
          await axios.post(`${STRAPI_URL}/messages`, {
            data: {
              contenu: `üéâ INVITATION √âV√âNEMENT ENVOY√âE !\n\nInvitation ${channel.toUpperCase()} envoy√©e √† ${contact.name} (${contact.relation})\nüìß ${contact.email}\n\nüì® "${invitation.subject}"\nüéØ ID: ${invitation.id}\n\nüëÄ En attente de confirmation... üìÖ`,
              typeConversation: 'evenement',
              dateEnvoi: new Date().toISOString(),
              expediteur: auth.user.id,
              evenement: event.id
            }
          }, { headers });
          
          console.log(`‚úÖ Invitation enregistr√©e dans √©v√©nement`);
          
        } catch (error) {
          console.log(`‚ùå Erreur enregistrement event: ${error.response?.data?.error?.message}`);
        }
        
        invitations.push({
          ...invitation,
          event_id: event.id,
          event_title: event.titre,
          contact_relation: contact.relation
        });
        
        await new Promise(resolve => setTimeout(resolve, 600));
      }
    }
    
    console.log(`\nüéâ ${invitations.length} invitations √©v√©nement envoy√©es`);
    return invitations;
    
  } catch (error) {
    console.log(`‚ùå Erreur invitations √©v√©nement: ${error.message}`);
    return [];
  }
}

async function simulateInvitationResponses(invitations) {
  console.log('\nüì± === SIMULATION R√âPONSES INVITATIONS ===');
  
  const responseTypes = [
    { type: 'interested', message: 'Super ! √áa m\'int√©resse ! üòä', probability: 0.4 },
    { type: 'confirmed', message: 'Parfait ! Je confirme ma participation ! üéâ', probability: 0.3 },
    { type: 'maybe', message: '√áa me tente mais je dois v√©rifier ma dispo... ü§î', probability: 0.2 },
    { type: 'declined', message: 'Merci pour l\'invitation mais je ne peux pas üòî', probability: 0.1 }
  ];
  
  const responses = [];
  
  for (const invitation of invitations.slice(0, 8)) { // Simuler 8 r√©ponses
    const random = Math.random();
    let cumulativeProbability = 0;
    let selectedResponse = responseTypes[0];
    
    for (const responseType of responseTypes) {
      cumulativeProbability += responseType.probability;
      if (random <= cumulativeProbability) {
        selectedResponse = responseType;
        break;
      }
    }
    
    console.log(`\nüì± R√©ponse √† l'invitation ${invitation.id}`);
    console.log(`üë§ ${invitation.invitee_name} r√©pond: ${selectedResponse.type}`);
    console.log(`üí¨ "${selectedResponse.message}"`);
    
    // Enregistrer r√©ponse selon type d'invitation
    try {
      const conversationType = invitation.type === 'bob' ? 'echange' : 'evenement';
      const itemId = invitation.type === 'bob' ? invitation.bob_id : invitation.event_id;
      
      // Simulation d'auth pour le r√©pondant (si utilisateur app)
      let responderAuth = null;
      if (invitation.invitee_email.includes('@bob.com')) {
        responderAuth = await authenticateUser(invitation.invitee_email);
      }
      
      if (responderAuth) {
        const responseMessage = `üì± R√âPONSE INVITATION via ${invitation.channel.toUpperCase()}\n\n${invitation.invitee_name} r√©pond: ${selectedResponse.type.toUpperCase()}\n\nüí¨ "${selectedResponse.message}"\n\nüéØ Invitation ID: ${invitation.id}`;
        
        const messageData = {
          contenu: responseMessage,
          typeConversation: conversationType,
          dateEnvoi: new Date().toISOString(),
          expediteur: responderAuth.user.id
        };
        
        if (invitation.type === 'bob') {
          messageData.echange = itemId;
        } else {
          messageData.evenement = itemId;
        }
        
        await axios.post(`${STRAPI_URL}/messages`, {
          data: messageData
        }, {
          headers: {
            'Authorization': `Bearer ${responderAuth.token}`,
            'Content-Type': 'application/json'
          }
        });
        
        console.log(`‚úÖ R√©ponse enregistr√©e dans conversation`);
      } else {
        console.log(`üìß R√©ponse externe (${invitation.invitee_email}) simul√©e`);
      }
      
      responses.push({
        invitation_id: invitation.id,
        respondent: invitation.invitee_name,
        response_type: selectedResponse.type,
        message: selectedResponse.message,
        channel: invitation.channel,
        responded_at: new Date().toISOString()
      });
      
    } catch (error) {
      console.log(`‚ùå Erreur r√©ponse: ${error.response?.data?.error?.message || error.message}`);
    }
    
    await new Promise(resolve => setTimeout(resolve, 400));
  }
  
  console.log(`\nüì± ${responses.length} r√©ponses trait√©es`);
  return responses;
}

async function generateInvitationAnalytics(bobInvitations, eventInvitations, responses) {
  console.log('\nüìä === ANALYTICS INVITATIONS PERSONNALIS√âES ===');
  
  const totalInvitations = bobInvitations.length + eventInvitations.length;
  const totalResponses = responses.length;
  const responseRate = totalInvitations > 0 ? ((totalResponses / totalInvitations) * 100).toFixed(1) : 0;
  
  // Analytics par canal
  const channelStats = {};
  [...bobInvitations, ...eventInvitations].forEach(inv => {
    channelStats[inv.channel] = (channelStats[inv.channel] || 0) + 1;
  });
  
  // Analytics par type de r√©ponse
  const responseStats = {};
  responses.forEach(resp => {
    responseStats[resp.response_type] = (responseStats[resp.response_type] || 0) + 1;
  });
  
  // Taux de conversion par canal
  const channelConversion = {};
  Object.keys(channelStats).forEach(channel => {
    const channelResponses = responses.filter(r => r.channel === channel).length;
    const channelInvitations = channelStats[channel];
    channelConversion[channel] = channelInvitations > 0 ? ((channelResponses / channelInvitations) * 100).toFixed(1) : 0;
  });
  
  console.log(`üíå INVITATIONS ENVOY√âES:`);
  console.log(`  üîÑ ${bobInvitations.length} invitations BOB`);
  console.log(`  üéâ ${eventInvitations.length} invitations √©v√©nements`);
  console.log(`  üìä Total: ${totalInvitations} invitations personnalis√©es`);
  
  console.log(`\nüì± R√âPARTITION PAR CANAL:`);
  Object.entries(channelStats).forEach(([channel, count]) => {
    console.log(`  üì§ ${channel.toUpperCase()}: ${count} invitations (${channelConversion[channel]}% r√©ponses)`);
  });
  
  console.log(`\nüì± R√âPONSES RE√áUES:`);
  console.log(`  üìä Total r√©ponses: ${totalResponses}`);
  console.log(`  üìà Taux de r√©ponse: ${responseRate}%`);
  
  if (Object.keys(responseStats).length > 0) {
    console.log(`\nüí¨ TYPES DE R√âPONSES:`);
    Object.entries(responseStats).forEach(([type, count]) => {
      const percentage = ((count / totalResponses) * 100).toFixed(1);
      console.log(`  ‚úÖ ${type}: ${count} (${percentage}%)`);
    });
  }
  
  // Calcul engagement
  const positiveResponses = (responseStats.interested || 0) + (responseStats.confirmed || 0);
  const engagementRate = totalResponses > 0 ? ((positiveResponses / totalResponses) * 100).toFixed(1) : 0;
  
  console.log(`\nüìà M√âTRIQUES ENGAGEMENT:`);
  console.log(`  üéØ Taux de r√©ponse global: ${responseRate}%`);
  console.log(`  üíö Taux d'engagement positif: ${engagementRate}%`);
  console.log(`  üìä Invitations actives: ${totalInvitations}`);
  console.log(`  üí´ Interactions g√©n√©r√©es: ${totalResponses}`);
  
  // Canal le plus efficace
  const bestChannel = Object.entries(channelConversion).reduce((best, [channel, rate]) => 
    parseFloat(rate) > parseFloat(best.rate) ? { channel, rate } : best
  , { channel: 'none', rate: '0' });
  
  console.log(`\nüèÜ PERFORMANCES:`);
  console.log(`  ü•á Canal le plus efficace: ${bestChannel.channel.toUpperCase()} (${bestChannel.rate}%)`);
  console.log(`  üì± Format privil√©gi√©: ${bobInvitations.length > eventInvitations.length ? 'BOB' : '√âv√©nements'}`);
  
  console.log(`\n‚úÖ FONCTIONNALIT√âS INVITATIONS COMPL√àTES:`);
  console.log(`  üíå Invitations personnalis√©es par canal (SMS/Email/App)`);
  console.log(`  üéØ Messages adapt√©s au type (BOB vs √âv√©nement)`);
  console.log(`  üë• Personnalisation selon relation (famille/ami/coll√®gue)`);
  console.log(`  üì± Actions rapides int√©gr√©es`);
  console.log(`  üí¨ Gestion r√©ponses en temps r√©el`);
  console.log(`  üìä Analytics d√©taill√©es par canal`);
  console.log(`  üîó Int√©gration conversations BOB/Event`);
  console.log(`  üì≤ Support utilisateurs externes (non-app)`);
}

async function main() {
  console.log('üíå === SYST√àME INVITATIONS PERSONNALIS√âES ===\n');
  console.log('üéØ Objectif: Invitations SMS/Email personnalis√©es pour Bobs et Events\n');
  
  // 1. Cr√©er invitations personnalis√©es pour Bobs
  const bobInvitations = await createPersonalizedInvitationsForBobs();
  
  // 2. Cr√©er invitations pour √©v√©nements
  const eventInvitations = await createPersonalizedInvitationsForEvents();
  
  if (bobInvitations.length === 0 && eventInvitations.length === 0) {
    console.log('‚ùå Aucune invitation cr√©√©e');
    return;
  }
  
  // 3. Simuler r√©ponses aux invitations
  const allInvitations = [...bobInvitations, ...eventInvitations];
  const responses = await simulateInvitationResponses(allInvitations);
  
  // 4. Analytics compl√®tes
  await generateInvitationAnalytics(bobInvitations, eventInvitations, responses);
  
  console.log('\n‚ú® === SYST√àME INVITATIONS TERMIN√â ! ===');
  console.log('üíå Invitations personnalis√©es SMS/Email cr√©√©es !');
  console.log('üì± Gestion r√©ponses automatique op√©rationnelle !');
  console.log('üìä Analytics invitations disponibles !');
}

main().catch(console.error);