// Syst√®me QR Codes pour Bobs et Events - Partage et scan rapide
const axios = require('axios');

const STRAPI_URL = 'http://46.202.153.43:1337/api';

let authCache = {};

async function authenticateUser(email) {
  if (authCache[email]) return authCache[email];
  
  try {
    const response = await axios.post(`${STRAPI_URL}/auth/local`, {
      identifier: email,
      password: 'password123'
    });
    
    authCache[email] = {
      token: response.data.jwt,
      user: response.data.user
    };
    
    return authCache[email];
  } catch (error) {
    console.log(`‚ùå Auth failed: ${email}`);
    return null;
  }
}

function generateQRCodeData(type, item) {
  // G√©n√©ration donn√©es QR Code sp√©cifiques BOB
  const baseUrl = 'https://bob-app.com';
  
  if (type === 'bob') {
    return {
      url: `${baseUrl}/bob/${item.documentId}`,
      data: {
        type: 'bob',
        id: item.documentId,
        titre: item.titre,
        type_echange: item.type,
        createur: item.createur,
        statut: item.statut,
        bobiz: item.bobizEchange || 10,
        timestamp: new Date().toISOString()
      },
      displayText: `BOB: ${item.titre}`,
      shareMessage: `üîÑ D√©couvre ce BOB sur l'app !\n"${item.titre}"\nüíé ${item.bobizEchange || 10} BOBIZ\n\nScanne le QR code ! üì±`
    };
  }
  
  if (type === 'event') {
    return {
      url: `${baseUrl}/event/${item.documentId}`,
      data: {
        type: 'event',
        id: item.documentId,
        titre: item.titre,
        dateDebut: item.dateDebut,
        adresse: item.adresse,
        organisateur: item.createur,
        statut: item.statut,
        bobizRecompense: item.bobizRecompense,
        maxParticipants: item.maxParticipants,
        timestamp: new Date().toISOString()
      },
      displayText: `EVENT: ${item.titre}`,
      shareMessage: `üéâ Rejoins cet √©v√©nement !\n"${item.titre}"\nüìÖ ${new Date(item.dateDebut).toLocaleDateString()}\nüìç ${item.adresse}\n\nScanne pour participer ! üì±`
    };
  }
  
  return null;
}

function simulateQRCodeGeneration(qrData) {
  // Simulation g√©n√©ration QR code (normalement avec qrcode library)
  const qrContent = JSON.stringify(qrData.data);
  const qrHash = Buffer.from(qrContent).toString('base64').substring(0, 12);
  
  return {
    qrId: `QR_${qrHash}`,
    url: qrData.url,
    content: qrContent,
    displayText: qrData.displayText,
    shareMessage: qrData.shareMessage,
    createdAt: new Date().toISOString(),
    format: 'base64_png',
    size: '256x256',
    status: 'generated'
  };
}

async function createQRCodesForBobs() {
  console.log('üì± === G√âN√âRATION QR CODES POUR BOBS ===');
  
  const auth = await authenticateUser('marie@bob.com');
  if (!auth) return [];
  
  const headers = { 'Authorization': `Bearer ${auth.token}` };
  
  try {
    const bobsResponse = await axios.get(`${STRAPI_URL}/echanges`, { headers });
    const bobs = bobsResponse.data.data.slice(0, 10); // Prendre 10 Bobs r√©cents
    
    const qrCodes = [];
    
    for (const bob of bobs) {
      console.log(`\nüì± QR Code pour BOB: ${bob.titre}`);
      
      // G√©n√©rer donn√©es QR
      const qrData = generateQRCodeData('bob', bob);
      const qrCode = simulateQRCodeGeneration(qrData);
      
      console.log(`‚úÖ QR g√©n√©r√©: ${qrCode.qrId}`);
      console.log(`üîó URL: ${qrCode.url}`);
      console.log(`üìÑ Texte: ${qrCode.displayText}`);
      
      // Simulation sauvegarde en base (normalement dans collection QRCodes)
      const qrCodeRecord = {
        qrId: qrCode.qrId,
        type: 'bob',
        itemId: bob.documentId,
        url: qrCode.url,
        content: qrCode.content,
        shareMessage: qrCode.shareMessage,
        createdBy: auth.user.id,
        createdAt: qrCode.createdAt,
        scansCount: 0,
        isActive: true
      };
      
      qrCodes.push(qrCodeRecord);
      
      // Message de cr√©ation QR dans la conversation du BOB
      try {
        await axios.post(`${STRAPI_URL}/messages`, {
          data: {
            contenu: `üì± QR CODE G√âN√âR√â !\n\nüîÑ Un QR code a √©t√© cr√©√© pour ce BOB !\n\n‚ú® Fonctionnalit√©s :\nüì§ Partage instantan√©\nüë• Invitation facile\nüìä Suivi des scans\n\nPartage-le avec tes amis ! üöÄ\n\nQR ID: ${qrCode.qrId}`,
            typeConversation: 'bob',
            dateEnvoi: new Date().toISOString(),
            expediteur: auth.user.id,
            echange: bob.id
          }
        }, { headers });
        
        console.log(`üí¨ Message QR ajout√© √† la conversation`);
        
      } catch (error) {
        console.log(`‚ùå Erreur message QR: ${error.response?.data?.error?.message}`);
      }
      
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    console.log(`\nüì± ${qrCodes.length} QR codes g√©n√©r√©s pour les Bobs`);
    return qrCodes;
    
  } catch (error) {
    console.log(`‚ùå Erreur g√©n√©ration QR Bobs: ${error.message}`);
    return [];
  }
}

async function createQRCodesForEvents() {
  console.log('\nüéâ === G√âN√âRATION QR CODES POUR √âV√âNEMENTS ===');
  
  const auth = await authenticateUser('thomas@bob.com');
  if (!auth) return [];
  
  const headers = { 'Authorization': `Bearer ${auth.token}` };
  
  try {
    const eventsResponse = await axios.get(`${STRAPI_URL}/evenements`, { headers });
    const events = eventsResponse.data.data;
    
    const qrCodes = [];
    
    for (const event of events) {
      console.log(`\nüéâ QR Code pour EVENT: ${event.titre}`);
      
      // G√©n√©rer donn√©es QR
      const qrData = generateQRCodeData('event', event);
      const qrCode = simulateQRCodeGeneration(qrData);
      
      console.log(`‚úÖ QR g√©n√©r√©: ${qrCode.qrId}`);
      console.log(`üîó URL: ${qrCode.url}`);
      console.log(`üìÑ Texte: ${qrCode.displayText}`);
      
      // Simulation sauvegarde
      const qrCodeRecord = {
        qrId: qrCode.qrId,
        type: 'event',
        itemId: event.documentId,
        url: qrCode.url,
        content: qrCode.content,
        shareMessage: qrCode.shareMessage,
        createdBy: auth.user.id,
        createdAt: qrCode.createdAt,
        scansCount: 0,
        isActive: true
      };
      
      qrCodes.push(qrCodeRecord);
      
      // Message QR dans l'√©v√©nement
      try {
        await axios.post(`${STRAPI_URL}/messages`, {
          data: {
            contenu: `üì± QR CODE √âV√âNEMENT CR√â√â !\n\nüéâ Partagez cet √©v√©nement facilement !\n\n‚ú® Le QR code permet :\nüë• Invitations rapides\nüì± Partage sur r√©seaux sociaux\nüìä Tracking participants\nüöÄ Check-in √©v√©nement\n\nDiffusez-le partout ! üì¢\n\nQR ID: ${qrCode.qrId}`,
            typeConversation: 'evenement',
            dateEnvoi: new Date().toISOString(),
            expediteur: auth.user.id,
            evenement: event.id
          }
        }, { headers });
        
        console.log(`üí¨ Message QR ajout√© √† l'√©v√©nement`);
        
      } catch (error) {
        console.log(`‚ùå Erreur message QR event: ${error.response?.data?.error?.message}`);
      }
      
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    console.log(`\nüéâ ${qrCodes.length} QR codes g√©n√©r√©s pour les Events`);
    return qrCodes;
    
  } catch (error) {
    console.log(`‚ùå Erreur g√©n√©ration QR Events: ${error.message}`);
    return [];
  }
}

async function simulateQRCodeScanning(qrCodes) {
  console.log('\nüì≤ === SIMULATION SCAN QR CODES ===');
  
  const allUsers = ['marie@bob.com', 'thomas@bob.com', 'sophie@bob.com', 'lucas@bob.com'];
  const scanResults = [];
  
  for (let i = 0; i < Math.min(qrCodes.length, 5); i++) {
    const qrCode = qrCodes[i];
    const scannerEmail = allUsers[Math.floor(Math.random() * allUsers.length)];
    const scannerAuth = await authenticateUser(scannerEmail);
    
    if (!scannerAuth) continue;
    
    console.log(`\nüì≤ ${scannerAuth.user.username} scanne QR: ${qrCode.qrId}`);
    
    try {
      // Simulation du scan - parsing des donn√©es QR
      const qrData = JSON.parse(qrCode.content);
      
      console.log(`üìÑ Type scann√©: ${qrData.type}`);
      console.log(`üéØ Titre: ${qrData.titre || qrData.nom}`);
      
      // Traitement selon le type
      if (qrData.type === 'bob') {
        // Scan d'un BOB - g√©n√©rer message d'int√©r√™t
        await axios.post(`${STRAPI_URL}/messages`, {
          data: {
            contenu: `üì± ARRIV√âE VIA QR CODE !\n\nSalut ! J'ai scann√© le QR code de ton BOB "${qrData.titre}" ! üòä\n\nüîÑ √áa m'int√©resse ! On peut en discuter ?\n\nüì± Super pratique ce syst√®me de QR ! üëç`,
            typeConversation: 'bob',
            dateEnvoi: new Date().toISOString(),
            expediteur: scannerAuth.user.id,
            echange: parseInt(qrData.id)
          }
        }, {
          headers: {
            'Authorization': `Bearer ${scannerAuth.token}`,
            'Content-Type': 'application/json'
          }
        });
        
        console.log(`üí¨ Message d'int√©r√™t envoy√© pour le BOB`);
        
      } else if (qrData.type === 'event') {
        // Scan d'un √©v√©nement - demande de participation
        await axios.post(`${STRAPI_URL}/messages`, {
          data: {
            contenu: `üì± ARRIV√âE VIA QR CODE √âV√âNEMENT !\n\nSalut ! J'ai scann√© le QR de ton √©v√©nement "${qrData.titre}" ! üéâ\n\nüóìÔ∏è Date: ${new Date(qrData.dateDebut).toLocaleDateString()}\nüìç Lieu: ${qrData.adresse}\n\nüë• Je peux participer ? C'est exactement ce que je cherchais ! üòç\n\nüì± Le QR code c'est g√©nial ! üöÄ`,
            typeConversation: 'evenement',
            dateEnvoi: new Date().toISOString(),
            expediteur: scannerAuth.user.id,
            evenement: parseInt(qrData.id)
          }
        }, {
          headers: {
            'Authorization': `Bearer ${scannerAuth.token}`,
            'Content-Type': 'application/json'
          }
        });
        
        console.log(`üí¨ Demande de participation envoy√©e pour l'√©v√©nement`);
      }
      
      // Enregistrer le scan (simulation)
      const scanRecord = {
        qrId: qrCode.qrId,
        scannedBy: scannerAuth.user.id,
        scannerUsername: scannerAuth.user.username,
        scannedAt: new Date().toISOString(),
        itemType: qrData.type,
        itemId: qrData.id,
        successful: true,
        userAgent: 'BOB Mobile App v1.0',
        location: 'Paris, France'
      };
      
      scanResults.push(scanRecord);
      console.log(`‚úÖ Scan enregistr√© avec succ√®s`);
      
    } catch (error) {
      console.log(`‚ùå Erreur scan QR: ${error.response?.data?.error?.message || error.message}`);
    }
    
    await new Promise(resolve => setTimeout(resolve, 500));
  }
  
  console.log(`\nüì≤ ${scanResults.length} scans QR effectu√©s avec succ√®s`);
  return scanResults;
}

async function simulateQRCodeSharing(qrCodes) {
  console.log('\nüì§ === SIMULATION PARTAGE QR CODES ===');
  
  const allUsers = ['marie@bob.com', 'thomas@bob.com', 'sophie@bob.com', 'lucas@bob.com'];
  const shareChannels = ['sms', 'email', 'whatsapp', 'social_media', 'direct_link'];
  
  for (let i = 0; i < Math.min(qrCodes.length, 6); i++) {
    const qrCode = qrCodes[i];
    const sharerEmail = allUsers[Math.floor(Math.random() * allUsers.length)];
    const sharerAuth = await authenticateUser(sharerEmail);
    
    if (!sharerAuth) continue;
    
    const channel = shareChannels[Math.floor(Math.random() * shareChannels.length)];
    
    console.log(`\nüì§ ${sharerAuth.user.username} partage QR via ${channel}`);
    console.log(`üéØ QR: ${qrCode.qrId}`);
    
    // Simulation du partage selon le canal
    let shareMessage = qrCode.shareMessage;
    
    switch (channel) {
      case 'sms':
        shareMessage += '\n\nEnvoy√© via SMS üì±';
        break;
      case 'email':
        shareMessage = `Sujet: ${qrCode.displayText}\n\n${shareMessage}\n\nEnvoy√© via email üìß`;
        break;
      case 'whatsapp':
        shareMessage += '\n\nPartag√© sur WhatsApp üí¨';
        break;
      case 'social_media':
        shareMessage += '\n\n#BobApp #Partage #QRCode üì±‚ú®';
        break;
      case 'direct_link':
        shareMessage = `Lien direct: ${qrCode.url}\n\n${shareMessage}`;
        break;
    }
    
    console.log(`üìù Message: ${shareMessage.substring(0, 100)}...`);
    
    // Enregistrer le partage (simulation)
    const shareRecord = {
      qrId: qrCode.qrId,
      sharedBy: sharerAuth.user.id,
      sharerUsername: sharerAuth.user.username,
      sharedAt: new Date().toISOString(),
      channel: channel,
      message: shareMessage,
      successful: true
    };
    
    console.log(`‚úÖ Partage ${channel} r√©ussi`);
    
    await new Promise(resolve => setTimeout(resolve, 400));
  }
  
  console.log(`\nüì§ Partages QR simul√©s sur tous les canaux`);
}

async function generateQRAnalytics(qrCodes, scanResults) {
  console.log('\nüìä === ANALYTICS QR CODES ===');
  
  const bobQRs = qrCodes.filter(qr => qr.type === 'bob');
  const eventQRs = qrCodes.filter(qr => qr.type === 'event');
  
  const bobScans = scanResults.filter(scan => scan.itemType === 'bob');
  const eventScans = scanResults.filter(scan => scan.itemType === 'event');
  
  console.log(`üì± QR CODES G√âN√âR√âS:`);
  console.log(`  üîÑ ${bobQRs.length} QR codes pour Bobs`);
  console.log(`  üéâ ${eventQRs.length} QR codes pour Events`);
  console.log(`  üìä Total: ${qrCodes.length} QR codes`);
  
  console.log(`\nüì≤ SCANS EFFECTU√âS:`);
  console.log(`  üîÑ ${bobScans.length} scans de Bobs`);
  console.log(`  üéâ ${eventScans.length} scans d'Events`);
  console.log(`  üìä Total: ${scanResults.length} scans`);
  
  if (scanResults.length > 0) {
    const scansByUser = {};
    scanResults.forEach(scan => {
      scansByUser[scan.scannerUsername] = (scansByUser[scan.scannerUsername] || 0) + 1;
    });
    
    console.log(`\nüë• SCANS PAR UTILISATEUR:`);
    Object.entries(scansByUser).forEach(([user, count]) => {
      console.log(`  üì± ${user}: ${count} scans`);
    });
  }
  
  const conversionRate = qrCodes.length > 0 ? ((scanResults.length / qrCodes.length) * 100).toFixed(1) : 0;
  
  console.log(`\nüìà M√âTRIQUES:`);
  console.log(`  üéØ Taux d'engagement: ${conversionRate}%`);
  console.log(`  üöÄ QR codes actifs: ${qrCodes.length}`);
  console.log(`  üí´ Interactions g√©n√©r√©es: ${scanResults.length}`);
  
  console.log(`\n‚úÖ FONCTIONNALIT√âS QR COMPL√àTES:`);
  console.log(`  üì± G√©n√©ration automatique pour Bobs et Events`);
  console.log(`  üîó URLs d√©di√©es avec donn√©es structur√©es`);
  console.log(`  üì≤ Syst√®me scan et traitement intelligent`);
  console.log(`  üì§ Partage multi-canaux (SMS, email, social)`);
  console.log(`  üí¨ Int√©gration conversations automatique`);
  console.log(`  üìä Analytics et suivi engagement`);
  console.log(`  üéØ Actions contextuelles selon type`);
}

async function main() {
  console.log('üì± === SYST√àME QR CODES COMPLET ===\n');
  console.log('üéØ Objectif: QR codes pour Bobs et Events avec partage et scan\n');
  
  // 1. G√©n√©rer QR codes pour Bobs
  const bobQRCodes = await createQRCodesForBobs();
  
  // 2. G√©n√©rer QR codes pour Events
  const eventQRCodes = await createQRCodesForEvents();
  
  const allQRCodes = [...bobQRCodes, ...eventQRCodes];
  
  if (allQRCodes.length === 0) {
    console.log('‚ùå Aucun QR code g√©n√©r√©');
    return;
  }
  
  // 3. Simuler scans de QR codes
  const scanResults = await simulateQRCodeScanning(allQRCodes);
  
  // 4. Simuler partages QR codes
  await simulateQRCodeSharing(allQRCodes);
  
  // 5. Analytics finales
  await generateQRAnalytics(allQRCodes, scanResults);
  
  console.log('\n‚ú® === SYST√àME QR CODES TERMIN√â ! ===');
  console.log('üì± QR codes pour Bobs et Events cr√©√©s !');
  console.log('üöÄ Partage et scan rapide op√©rationnels !');
}

main().catch(console.error);